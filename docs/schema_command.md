# The `schema` command

The `schema-enforcer schema` command is used to manage schemas. It can:

- List defined schemas, along with their type, location, and filename.
- Check that defined schemas are valid as schema definitions, and that schema unit tests pass.
- Generate invalid test results given a set of data which is intended to fail schema validation.

## Listing defined schemas

The `schema enforcer schema --list` command can be used to print out a table of defined schemas. These schemas are loaded based on the directory sctructure elucidated in the [README.md](../README.md) file at the root of the repository in the overview section.

```cli
bash$ cd examples/example3
bash$ schema-enforcer schema --list
```
![Schema List Command](assets/images/schema_list.png)

## Checking defined schemas

The `schema-enforcer schema --check` command both validates that schemas are valid according to spec (e.g. JSONSchema type schemas are validated as defined correctly according to the JSONSchema spec) and runs unit tests. 

```cli
bash$ cd examples/example3
bash$ schema-enforcer schema --check
ALL SCHEMAS ARE VALID
```

Unit tests for schemas expect a certain directory hierarchy. Tests are placed inside of a schema-id specific directory which is nested in the `test_directory` (defaults to `tests`). The test_directory must be nested inside of the `main_directory`, which defaults to `schema`.

```cli
bash$ tree schema -L 2
schema
├── definitions
│   ├── arrays
│   ├── objects
│   └── properties
├── schemas
│   ├── dns.yml
│   ├── ntp.yml
│   └── syslog.yml
└── tests
    ├── dns_servers
    ├── ntp
    └── syslog_servers

9 directories, 3 files
```

> Note: The names of the main_directory and test_directory can be configured in a pyproject.toml file if you want to override the defaults. See [configuration.md](./configuration.md) for more information on how to do so.

When putting tests into a directory for a given schema ID, the short form of the schema ID is used as the directory name. The short form of the schema ID is generated by removing `/` from the schema ID and anything proceeding it. For example, the name of the test directory for the schema ID `schemas/ntp` is named `ntp` in the example above.

In example 3, tests have been written for three different schema definitions and placed in the directories `schemas/dns_servers`, `schemas/ntp`, and `schemas/syslog_servers`. We'll look at the tests written for the `schemas/ntp` schema ID in the following example.

```cli
bash$ cd examples/example3
bash$ tree schema/tests/ntp
├── invalid
│   ├── invalid_format
│   │   ├── data.yml
│   │   └── results.yml
│   ├── invalid_ip
│   │   ├── data.yml
│   │   └── results.yml
│   └── missing_required
│       ├── data.yml
│       └── results.yml
└── valid
    ├── full_implementation.json
    └── partial_implementation.json
```

Nested inside of the tests folder for each schema ID, there is an `invalid` directory and a `valid` directory. Tests which purposely generate invalid results (e.g. assert that a given set of data data fails to adhere to the schema definition) should be placed inside of the invalid directory. Tests which purposely generate valid results (e.g. assert that a a given set of data adheres to the schema definition) should be placed in the `valid` directory.

In the invalid directory, thre different test cases exist -- `invalid_format`, `invalid_ip`, and `missing_required`. Each of these test cases contains a `data` file and a `results` file. When we assert that data fails to adhere to a given schema, we want not just to assert that it failed, but that it failed in the specific way we were expecting. This is why the invalid tests are each directories with data and results defined.

In the valid directory, two different test cases exist -- `full_implementation` and `partial_implementation`. When we assert that data adheres to schema, there is no need to define the specific way in which validation passed, just that it passed. This is why these test cases are simply files of data which should pass schema validation rather than a directory with two separate file indicate data which should fail and the specific anticipated failure.

> Note: both valid and invalid test case data and results files can be named with extensions of .yml, .yaml, or .json.

In the following example, the `schemas/ntp` schema has an `invalid_format` test case defined. The data for the test case is as follows.

```yaml
bash$ cat schema/tests/ntp/invalid/invalid_format/data.yml
---
ntp_servers:
  - "10.1.1.1"
```

Because the folder in which the test case exists is named `ntp`, the schema used to validate data The following is the schema being used to validate the data per the code snippet above.

```yaml
bash$ cat schema/schemas/ntp.yml
---
$schema: "http://json-schema.org/draft-07/schema#"
$id: "schemas/ntp"
description: "NTP Configuration schema."
type: "object"
properties:
  ntp_servers:
    $ref: "../definitions/arrays/ip.yml#ipv4_hosts"
  ntp_authentication:
    type: "boolean"
  ntp_logging:
    type: "boolean"
additionalProperties: false
required:
  - "ntp_servers"
something: "extra"
```